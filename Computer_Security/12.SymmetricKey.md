### 12.1 대칭키 암호의 개념

- 대칭키 암호
  - 암호화와 복호화에 하나의 같은 비밀키를 사용하는 암호 방식
  - $C = E_k(P)$ : 평문 $P$를 암호화할 때 비밀키 $K$를 이용하여 암호문 $C$를 만듦
  - $P = D_k(C)$ : 암호문 $C$를 복호화할 때 동일한 비밀키 $K$를 이용해야만 원래의 평문 $P$를 만듦
  - 다양한 이름들 : 대칭키 암호, 비밀키 암호, 단일키 암호, 관용 암호

---

### 12.2 블록 암호

#### 12.2.1 블록 암호의 개념

- 블록 암호 : 암호문을 만들기 위해 평문을 고정된 크기의 블록으로 나누어서 각 블록마다 암호화 과정을 수행하여 블록 단위로 암호문을 얻는 대칭키 암호 방식

#### 12.2.2 블록 암호 알고리즘의 구조

1. 출력 블록의 각 비트는 입력 블록과 키의 모든 비트에 영향을 받음
2. 주로 단순한 함수를 반복적으로 적용함으로써 암호학적으로 강한 함수를 만듦

- 라운드 함수 : 반복되는 함수
- 라운드 키 : 라운드 함수에 적용하는 키
- 키 스케줄 : 키를 입력하여 라운드 키를 발생시키는 과정

3. 파이스텔(Feistel) 구조

- 하나의 입력 블록을 분할하여 좌우 두 개의 블록($L, R$)으로 구분한 후 짝수 번의 라운드를 진행하는 구조
- 각 라운드의 출력 블록이 다음 라운드의 입력 블록이 됨
- $i$번째 라운드 과정(라운드 함수 $f$, 라운드 키 $K_i$)
  - $L_i = R_{i-1}$
  - $R_i = L_{i-1}\oplus f(R_{i-1}, K_i)$
- 라운드 함수와 관계없이 역변환이 가능
- 두 번의 수행으로 블록 간의 완전한 확산(diffusion)이 이루어짐
- DES, SEED 등 많은 블록 암호에서 사용됨

4. SPN(Substitution Permutation Network) 구조

- 하나의 입력 블록을 여러 개의 소블록으로 나눈 후 라운드를 진행하는 구조
- 각 라운드의 출력 블록이 다음 라운드의 입력 블록이 됨
- 각 소블록을 S\-box로 입력하여 치환시키고 S\-boxd의 출력을 P\-box로 전치하여 출력 블록을 생성
- 라운드 함수가 역변환 가능해야 함
- 더 많은 병렬성을 제공
- AES, ARIA 등 최근의 블록 암호에서 사용됨

#### 12.2.3 블록 암호 사용 모드

1. 전자 코드 북(ECB) 모드

- 각 블록을 독립적으로 암호화
- 암/복호화 시 병렬처리 가능
- 하나의 암호문에 오류가 발생해도 다른 블록에 영향이 없음
- 동일한 평문 블록은 동일한 암호문을 생성하기 때문에 패턴 분석이 가능하여 안전성에 문제

2. 암호 블록 연결(CBC) 모드

- 생성한 암호문 블록이 다음 평문 블록에 영향을 미치게 암호화
- 동일한 평문 블록이어도 서로 다른 암호문을 생성
- 암호화는 병렬처리 불가능하나 복호화는 가능
- 하나의 암호문에 오류ㅠ가 발생해도 그 다음 평문 이외의 다른 평문에는 영향이 없음
- 암호화 시 평문 블록에 오류가 발생하면 그 다음의 모든 암호문이 영향을 받음 $\to$ 메시지 인증에 사용

3. 암호 피드백(CFB) 모드

- 초기치(IV)를 암호화한 값과 평문 블록을 XOR하여 암호화하고, 그 암호문을 다음 블록의 초기치로 사용하여 암호화
- 복호화 함수 필요 없음
- 암호화 시 평문 블록에 오류가 발생하면 그 다음의 모든 암호문이 영향을 받음 $\to$ 메시지 인증에 사용

4. 출력 피드백(OFB) 모드

- 초기치(IV)를 암호화한 값과 평문 블록을 XOR하여 암호화하고, 초기치를 암호화한 값을 다음 블록의 초기치로 사용하여 암호화
- 복호화 함수 필요 없음
- 오류의 확산이 일어나지 않음

5. 카운터(CTR) 모드

- $i$번째 블록은 초기치(IV)+($i$-1)을 암호화한 값과 평문 블록을 XOR하여 암호화
- 암/복호화 시 병렬처리 가능
- 오류의 확산이 일어나지 않음
- EBC 모드처럼 간단하지만 안정성이 보장됨

---

### 12.3 스트림 암호

#### 12.3.1 스트림 암호의 개념

- 스트림 암호 : 평문과 같은 길이의 키 스트릠을 생성하여 평문과 키를 비트 단위로 XOR하여 암호문을 얻는 대칭키 암호 방식

#### 12.3.2 키 스트림 생성

1. 키 스트림

- 임의의 길이의 평문이 주어지더라도 동일한 길이의 키 스트림을 생성해야 함
- 생성되는 키 스트림은 규칙성이 없어 예측이 불가능한 랜덤 수열이어야 안전
- 의사 랜덤(pseudorandom) 수열 생성에 대한 연구가 많이 진행됨

2. 선형 귀한 시프트 레지스터(LFSR)

- m비트의 초깃값을 이용하여 최대 $2^m$-1 비트의 주기를 갖는 키 스트림을 생성할 수 있는 방식
- 직전 m개의 비트 값을 선형 결합하여 또 하나의 새로운 비트 값을 얻는 방식으로 키 스트림을 생성
- LFSR을 단독으로 사용하는 것은 쉽게 해독되기 때문에 출력 수열을 비선형 결합하여 스트림 암호를 구성해야 함

---

### 12.4 대칭키 암호 알고리즘들

#### 12.4.1 DES(Data Encryption Standard)

1. 1977년 미국에서 데이터 암호 알고리즘의 표준으로 공표
2. 2001년 AES가 나오기 전까지 가장 널리 사용된 암호 알고리즘

- DES는 키의 길이가 짧고 컴퓨터 속도 개선, 암호해독 기술의 발전으로 더 이상 안전하지 않게 됨

3. DES의 구조

- 64비트의 평문을 64비트의 암호문으로 만드는 블록 암호 알고리즘
- 56비트의 키를 사용
- 파이스텔 구조
- 16라운드로 구성
- 각 라운드마다 전치 및 치환의 과정을 거친 평문과 48비트의 라운드 키가 섞여 암호문을 생성

#### 12.4.2 TDEA(Triple Data Encryption Algorithm)

1. DES의 56비트라는 짧은 키 길이로 인한 안전성 문제를 해결하기 위한 대안
2. 3개의 키로 DES를 3회 반복하여 사용하는 알고리즘(3DES)

- 실제 동작에서는 두 개의 키를 사용
- 키 $k_1$으로 암호화 $\to$ 키 $k_2$로 복호화 $\to$ 키 $k_1$으로 암호화

3. DES보다 3배 정도 느림

#### 12.4.3 AES(Advanced Encryption Standard)

1. DES를 대신하는 표준 대칭키 암호 시스템
2. 2001년 미국 NIST에서 공포

- 공모를 통해 라인달(Rijndael)을 AES로 선정

3. AES의 구조

- 128비트의 평문을 128비트의 암호문으로 만드는 블록 암호 알고리즘
- 128비트, 192비트, 256비트의 키 중 택일
- SPN 구조
- 키 길이에 따라 다른 라운드 수
- 각 라운드마다 SubBytes, ShiftRows, MixColumns, AddRoundKey 연산을 128비트의 라운트 키와 섞여 암호문을 생성

4. AES의 라운드 수($N_r$)

- AES\-128 : 10라운드
- AES\-196 : 12라운드
- AES\-256 : 14라운드

5. 암호화 과정

- 초기 평문과 라운드 키를 AddRoundKey 연산
- SubBytes, ShiftRows, MixColumns, AddRoundKey를 $N_r - 1$ 라운드 반복
- SubBytes, ShiftRows, AddRoundKey를 한 라운드 적용

6. 복호화 과정

- 라운드 키는 암호화의 역순으로 사용
- 초기 암호문과 라운드 키를 AddRoundKey 연산
- InvShiftRows, InvSubBytes, AddRoundKey, InvMixColumn를 $N_r - 1$ 라운드 반복
- InvShiftRows, InvSubBytes, AddRoundKey를 한 라운드 적용
