### 클래스와 상속

#### 추상화

- 사물을 표현할 때 복잡하고 구체적인 모든 사실이 아니라 전형적이고 필요한 부분만 가지고 표현하는 것이다.
- 실세계의 사물이나 개념을 Java 프로그램에서 추상화하여 표현할 때 클래스를 사용한다.
- 클래스에서는 표현대상의 상태를 나타내기 위해 필드를 포함하고 상태제어를 위한 메소드를 함께 포함한다.

#### 클래스 정의

- 클래스를 정의할 때, 개별 객체의 상태정보를 저장하는 필드와 개별 객체의 행동 양식을 규정하는 메소드를 포함할 수 있다.
- 클래스는 생성자를 포함할 수 있으며, 생성자는 메소드의 특별한 경우로 볼 수 있다.
- 필드를 멤버 필드, 멤버 변수 또는 인스턴스 변수라고 부르고, 메소드를 멤버 메소드라고 부르기도 한다.

```java
// 클래스 정의 문법
// 대괄호 부분은 선택사항으로 생략 가능하다.
[접근제어자] class 클래스 이름 [extends 슈퍼 클래스 이름]
                [implements 인터페이스 이름] {
                    필드 선언;
                    ...
                    메소드 선언; 또는 메소드 구현
                    ...
                }
```

- 키워드 extends 다음에는 슈퍼 클래스의 이름이 나온다. Java 언어에서는 클래스의 다중상속을 허용하지 않으므로 하나의 슈퍼 클래스만 이용할 수 있다.
- 키워드 implements 다음에는 인터페이스의 이름이 나온다. 인터페이스는 다중상속이 가능하므로 콤마(,)로 구분하여 인터페이스의 이름을 나열할 수 있다.

#### 클래스의 접근 제어자

- 정의된 클래스의 사용범위를 제어하기 위한 키워드로 public, 생략, protected, private가 있다.
- 클래스의 접근 제어자는 클래스의 가시성을 나타낸다.
- 접근성을 의미하는 것은 아니나 final, abstract 키워드가 class 키워드의 왼편에 나올 수 있다.
- public 클래스는 어디서나 사용가능한 클래스를 의미한다.
- 접근 제어자가 생략된 경우를 '패키지 접근 수준'이라 한는데 같은 패키지에 있는 다른 클래스에서 사용할 수 있는 클래스를 의미한다.
- protected 클래스와 private 클래스는 중첩 클래스의 내부에 위치하는 클래스를 정의하는 경우에만 가능하다. 클래스 정의가 다른 클래스의 내부에 위치하는 경우 이 클래스를 내부(nested) 클래스라 하고, 그렇지 않은 경우 톱레벨 클래스(또는 외부 클래스)라고 한다.
- 톱레벨 클래스의 접근 제어자는 public과 생략만 가능하다.

#### final 메소드와 final 클래스

- final 메소드는 서브 클래스가 상속을 받을 수 있지만 서브 클래스에서 오버라이딩할 수 없는 메소드를 의미한다.
- final 클래스는 상속될 수 없는 클래스를 정의하기 위한 것이다. 즉, final 클래스는 다른 클래스의 슈퍼 클래스가 될 수 없다.

#### 생성자

- 객체를 생성하기 위해 클래스에 생성자를 정의해야 한다.
- 객체를 생성할 때 생성자가 자동으로 호출되며 일반 메소드처럼 임의로 호출할 수 없다.
- 생성자의 기능은 객체가 가지는 필드의 값을 초기화하는 것이다.
- 생성자의 이름은 클래스의 이름과 같아야 하며 반환형을 명시해서는 안 된다.
- 매개변수가 없는 생성자를 기본 생성자라 한다.
- 클래스 정의에서 어떠한 생성자도 정의하지 않았다면, 컴파일러는 기본 생성자를 자동으로 만들어 준다.
- 슈퍼 클래스를 상속받아 클래스를 정의한 경우, 생성자가 실행될 때 슈퍼 클래스의 매개변수 없는 생성자가 자동으로 호출된다.
- 클래스에 여러 생성자가 정의될 수 있으며 매개변수에 의해 구분되어야 한다. 객체가 생성될 때 매개변수가 일치하는 생성자 한 개가 실행된다.
- 일반적으로 생성자의 접근 제어자는 public이다.

```java
// Circle 클래스와 생성자
public class Circle {
    int r;
    public Circle(int a) {
        r = a;
    }
    public double getArea() {
        return r * r * 3.14;
    }
}
```
